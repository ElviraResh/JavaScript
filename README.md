# [Рекурсия](https://y-doka.site/js/long/recursion/)

*Рекурсия* - это что-то, что описывает само себя.

В программировании под рекурсией чаще всего понимают функцию, которая вызывает саму себя.

При решении некоторых задач мы можем обнаружить, что решение можно разбить на несколько простых действий и более простой вариант той же задачи.

Например, при возведении числа в степень мы берём число, умножаем его на себя несколько раз. Эту операцию можно представить в виде:

```sh
// 2^5 = 2 * 2 * 2 * 2 * 2
//
// 1 шаг: 2
// 2 шаг: 2 * 2
// 3 шаг: 2 * 2 * 2
// 4 шаг: 2 * 2 * 2 * 2
// 5 шаг: 2 * 2 * 2 * 2 * 2
//
// Какой по счёту шаг —
// столько и умножений.
```
Но это же можно представить в виде нескольких последовательных умножений на 2:
```sh
// 2^5 = ((((2 * 2) * 2) * 2) * 2)
//
// 1 шаг: 2
// 2 шаг: 2 * 2  (результат 1-го шага * 2)
// 3 шаг: 4 * 2  (результат 2-го шага * 2)
// 4 шаг: 8 * 2  (результат 3-го шага * 2)
// 5 шаг: 16 * 2  (результат 4-го шага * 2)
//
// Для получения нового результата
// мы берём предыдущий и умножаем его на 2.
```
При таком представлении всё возведение в степень — это лишь умножение предыдущего результата на 2:
```sh
// 2^n = 2^(n-1) * 2
// Значение степени двойки —
// это предыдущее значение, умноженное на 2.
```
Именно такие задачи называются рекурсивными — когда часть условия ссылается на всю задачу в целом (или похожую на неё).

У рекурсии 2 составляющие: повторяющиеся операции и базовый случай.

**Повторяющиеся операции**
Такие операции могут быть сложными и включать в себя несколько подзадач. Такое, например, часто встречается в математике.
```sh
Знаменитая сумма всех натуральных чисел контринтуитивно равняется -1/12. А доказывается это именно рекурсивно.
```
**Базовый случай**
Вторая важная часть рекурсии — это базовый случай.
```sh
Базовый случай — это условие, при выполнении которого рекурсия заканчивается и функция больше не вызывает саму себя.
```

Без базового случая любая рекурсивная функция уйдёт в бесконечное выполнение, потому что будет вызывать себя без конца.

### Цикл и рекурсия
Из-за повторяющихся операций рекурсия схожа с циклом. Их часто считают взаимозаменяемыми, но это всё же не совсем так.

Рекурсия проигрывает циклу в следующем:

* Отлаживать рекурсию значительно сложнее, чем цикл, а если функция написана плохо — то и просто читать.
* Она может приводить к переполнению стека. Особенно это ощутимо в таких языках как JS, где переполнение стека может наступить раньше базового случая с высокой вероятностью.
* Её выполнение может (хотя не обязательно) занимать больше памяти.

Цикл же проигрывает рекурсии в таких вещах:

* Его нельзя использовать в функциональном программировании, потому что он императивен.
* Циклом гораздо сложнее обходить вложенные структуры данных, например, каталоги файлов.
* Результат выполнения рекурсивной функции проще закешировать, чтобы ускорить выполнение, с циклом это сделать сложнее.
* При работе с общими ресурсами или асинхронными задачами чаще удобнее использовать рекурсивные функции из-за замыканий.
Поэтому на вопрос «Что использовать: рекурсию или цикл?» ответом будет «Зависит от задачи», серебряной пули здесь нет :–)
