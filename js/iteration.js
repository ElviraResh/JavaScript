//Итерация
"use strict"
// state (состояние) - все что программа помнит в конкретный момент времени (вычесления, константы, функции)
// Рекурсивный процесс и итеративный процесс - описывают рекурсию
// Суть рекурсивного процесса в откладывании на потом (пока не спустимся к базовому случаю)
// Суть итеративного процесса - когда может быть описано фиксированным количеством значений

// Рекурсивный процесс
/* const factorial = n => {
    if (n === 0) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}

console.log(factorial(3)); */

// Итеративный процесс
// counter - отслеживание движения от n до 1
// accumulator (acc) - текущий результат умножения чисел от n до 1
/* const factorial = n => {
    const iter = (counter, acc) => {
        if (counter === 1) {
            return acc;
        }
        return iter(counter - 1, counter * acc)
    };
    return iter(n, 1);
}

console.log(factorial(3)); */
// Внутри ящика iter 
// iter(3, 1); //iter(3 - 1, 3 * 1);
// iter(2, 3); //iter(2 - 1, 2 * 3);
// iter(1, 6); //iter(1 - 1, 1 * 6);
// iter(0, 6); //counter === 0, return 6;
// 6;

//Практические задачи

/* const sum1 = n => (n === 1) ? 1 : n + sum1(n - 1);
const sum2 = n => (n === 1) ? 1 : sum2(n - 1) + n;
sum1(4); // 4 + (3 + (2 + 1));
sum2(4); // ((1 + 2) + 3) + 4; */



/* Задача
Реализовать функцию, которая определяет, является ли переданное число натуральной степенью тройки.
Пример: 27 - это третья степень 3 ** 3, а 81 это 3 ** 4.
 
myFunction(9); // true
myFunction(2); // false */

/* const isPowerThree = n => {
    if (n % 3 !== 0) {
        return false
    } else {
        return true
    }
}

console.log(isPowerThree(5)); */

// Реализовать тело функции, используя итеративный процесс.
// Функция должна находить наименьший делитель заданного числа. Число, передаваемое в функцию, больше нуля.
// Доп.условие: делитель должен быть больше единицы, за исключением случая, когда аргументом является 1 (наименьшим делителем которой является так же 1).
 
// myFunction(15); // 3
// myFunction(17); // 17
 
// Идея
/* 1) пробуем разделить число на 2
2) если число делится без остатка, то это наименьший делитель.
3) если нет, то пробуем следующий делитель
4) если ничего не делит число без остатка, то переданное число, яв-ся простым(так что его наименьший делитель - оно само).
  */


const smallestDivisor = num => {
    const iter = acc => {
        if (acc > num / 2) {
            return num;
        }
        if (num % acc === 0) {
            return acc;
        }
        return iter (acc + 1);
    };
    return iter(2);
};

console.log(smallestDivisor(15));


